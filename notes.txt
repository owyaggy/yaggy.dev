## COMMON COMMAND LINE COMMANDS ##

$ ls -l                 # adding the flag -l is an option for a long listing format
$ ls -h                 # the -h flag signifies --human-readable (express memory in appropriate unit)
                        # single-hyphen flags are usually one letter options:   -h
                        # double-hyphen flags are usually multi-word options:   --human-readable

* Navigating the filesystem *
$ cd files              # navigate directory to specific directory called 'files'
$ cd /                  # navigate to primary directory
$ cd /home/owen/files   # navigate using absolute path (relative path: starting from pwd)
$ cd ..                 # return to parent directory
$ cd ../..              # return to parent of parent directory
$ cd ~                  # return to home directory
$ cd                    # return to home directory
$ pwd                   # display present working directory (absolute path to)
$ ls                    # list files in pwd
$ ls /home              # list files in specified path

* Creating, modifying and viewing files *
$ mkdir files                           # creates a directory called files
$ mkdir -p other/files                  # creates parent directories (use when also creating 'other')
$ touch ocean.txt                       # creates/modifies file (can do multiple at once)
$ echo Hello, World!                    # terminal will repeat back 'Hello, World!'
$ echo "Sammy the Shark" > sammy.txt    # adds text to a new file ('>': redirection operator)
$ cat sammy.txt                         # "concatenate": show file contents and return to prompt
$ echo "Mariana Trench???" > ocean.txt  # echo can work on existing files
$ nano sammy.txt                        # opens simple text editor working on sammy.txt (^O to save)
$ mv sammy.txt students                 # moves file to directory
$ mv sammy.txt students/sammy.txt       # same function, but also allows for file renaming
        # DANGER: no safeties on accidentally overwriting files! they'll be deleted!
$ mv students/sammy.txt .               # moves file to current directory (pwd)
$ mv students pupils                    # rename the directory, but maintaining contents
$ cp sammy.txt alex.txt                 # copy file
$ cp -r students pupils                 # copy a directory using -r option to copy contents also
$ less sammy.txt                        # fills terminal window with file
    # navigation: up/down arrows, page up/down buttons, ctrl-b/f
    # search: /text_to_find (matching case), n for next result, N for previous
    # type 'q' to exit the 'less' program
$ head sammy.txt                        # shows first 10 lines by default
$ tail sammy.txt                        # shows last 10 lines by default


* Autocompletion and history *
$ history       # summons entire history of command line session

* Working with files from the web
$ curl example.com/articles/news.txt            # transfers data from web to terminal (text outputted)
$ curl -O example.com/articles/news.txt         # flag -O downloads file, taking name of remote file
$ curl -o example.com/articles/news.txt old.txt # flag -o is same, but can rename file as argument

* Removing files and terminating commands *
$ rm sammy.txt      # irreversibly delete a file
$ rmdir students    # delete an EMPTY directory
$ rm -r students    # recursively delete directory (deletes contained files)
$ exit              # ends session
$ logout            # ends session

* Using options *
Options follow a command and are indicated by a single '-' character followed by one or more options,
which are represented by individual upper- or lower-case letters. Some multi-word options can start
with --, followed by the flag text. Options are also called flags or switches.
Options can be combined in several ways: '$ls -l -a', '$ls -al', '$ls -la /home'

Examples for $ls:
-l: print a "long listing" with extra details (e.g. permissions)
-a: list all a directory's files, including hidden ones (starting with '.')
-h: (--human-readable) express memory in understandable units when looking at long listings

* Understanding detailed file info *
Example: drwxrwxr-x 2 owen owen 4.0K Jul 22 04:00 files
d: directory (beginning with '-' signifies non-directory file)
r: read (permission to open and read a file/list directory contents)
w: write (permission to modify file content, add/remove/rename directory files)
x: execute (permission to run program files, enter/access directory files)

In order:   d -> directory
            rwx  -> permissions for directory owner (hyphen indicates absence of that permission)
            rwx  -> group permissions for directory
            rwx  -> permissions for other groups that have access to the machine
            2    -> the number of links in the file (here: 1-link to file, 2-self-referential link)
            owen -> owner of directory and its creator
            owen -> group with access to directory
            4.0K -> memory allocation for the directory
            date -> date last modified

* Environment variables *
$ env           # view all current environment variables
$ echo $PATH    # prints value of PATH variable
$ VAR=value     # set value of a variable (creates VAR or overwrites existing value)
$ export PATH=$PATH:/opt/app/bin
                # add /opt/app/bin to the PATH environment variable (only current session)

The PATH environment variable is a colon-delimited list of directories where the shell will look for
executable programs or scripts when a command is issued.

## FIREWALLS ##
- If there's a problem loading a webpage that should be hosted on DigitalOcean (DO), check the firewall
    - Currently enabled: DO Firewall https://cloud.digitalocean.com/networking/firewalls/
    - There's also the ufw firewall, enabled from the command line:

$ ufw status        # shows what's currently allowed through the firewall
$ ufw app list      # shows apps available to allow through firewall
$ ufw allow OpenSSH # allows a particular app


## NGINX ##
Check status of nginx web server:
$ sudo systemctl status nginx

Start the web server when it is stopped:
$ sudo systemctl start nginx

Stop the web server:
$ sudo systemctl stop nginx

Stop and start web server again:
$ sudo systemctl restart nginx

If making configuration changes take effect without restarting web server (not always possible):
$ sudo systemctl reload nginx

Disable nginx starting automatically when server boots:
$ sudo systemctl disable nginx

Enable nginx starting automatically when server boots (default):
$ sudo systemctl enable nginx

Test to make sure there are no syntax errors in any Nginx files:
$ sudo nginx -t

Setting up a server block for a new domain:
$ sudo mkdir -p /var/www/your_domain/html               # making directory for it (-p creates parent dirs)
$ sudo chown -R $USER:$USER /var/www/your_domain/html   # assign ownership of directory
$ sudo chmod -R 755 /var/www/your_domain                # test ownership is correct
$ nano /var/www/your_domain/html/index.html             # makes a landing page - customize as desired
$ sudo nano /etc/nginx/sites-available/your_domain      # makes a configuration block - see below:

'/etc/nginx/sites-available/your_domain':
server {
        listen 80;
        listen [::]:80;

        root /var/www/your_domain/html;
        index index.html index.htm index.nginx-debian.html;

        server_name your_domain www.your_domain;

        location / {
                try_files $uri $uri/ =404;
        }
}

- Then enable file by linking it (see below)

Enable a file in 'sites-available' by creating a link from it to the 'sites-enabled' directory:
$ sudo ln -s /etc/nginx/sites-available/your_domain /etc/nginx/sites-enabled/

* Important Nginx Files and Directories *
Content
- '/var/www/html': Actual web content, by default only the default Nginx page. Can be changed by altering
  Nginx config files

Server Configuration
- '/etc/nginx/': The Nginx configuration directory. All of the Nginx configuration files reside here.
- '/etc/nginx/nginx.conf': The main Nginx configuration file. Can be modified to make changes to the Nginx
  global configuration.
- '/etc/nginx/sites-available/': The directory where per-site server blocks will be stored. Nginx will not
  use the configuration files found in this directory unless they are linked to the 'sites-enabled'
  directory. Typically, all server block configuration is done in this directory, and then enabled by
  linking to the other directory.
- '/etc/nginx/sites-enabled/': The directory where enabled per-site server blocks are stored. Typically,
  these are created by linking to configuration files found in the 'sites-available' directory.
- '/etc/nginx/snippets': This directory contains configuration fragments that can be included elsewhere in
  the Nginx configuration. Potentially repeatable configuration segments are good candidates for
  refactoring into snippets.

Server Logs
- '/var/log/nginx/access.log': Every request to your server is recorded in this log file unless Nginx is
  configured to do otherwise.
- '/var/log/nginx/error.log': Any Nginx errors will be recorded in this log.

## CERTBOT / Automatic SSL
Certbot is a software client provided by Let's Encrypt that helps automate and simplify the process of
obtaining and renewing free SSL certificates.

1. Install Certbot
$ sudo snap install core; sudo snap refresh core    # make sure snap is up-to-date
$ sudo apt remove certbot                           # remove older version of certbot, if exists
$ sudo snap install --classic certbot               # install certbot package
$ sudo ln -s /snap/bin/certbot /usr/bin/certbot     # allow running certbot by typing only 'certbot'

2. Confirm Nginx Configuration
- 'server_name' in '/etc/nginx/sites-available/example.com' should be set up:
    ...server_name example.com www.example.com...
- reload nginx if necessary

3. Allow HTTPS through firewall

4. Obtain SSL Certificate
$ sudo certbot --nginx -d example.com -d www.example.com    # installs ssl certificate!
- Automatically redirects http:// to https://

5. Certbot Auto-Renewal
- Certbot handles this automatically. Let's Encrypt SSL certificates only last for 90 days, and certbot
  auto-renews it when it is 30 days from expiration by running a check twice a day.

$ sudo systemctl status snap.certbot.renew.service      # check that the timer is working
$ sudo certbot renew --dry-run                          # test renewal process